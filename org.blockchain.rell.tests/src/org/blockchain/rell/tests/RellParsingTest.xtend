/*
 * generated by Xtext 2.14.0
 */
package org.blockchain.rell.tests

import com.google.inject.Inject
import org.blockchain.rell.rell.Model
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(RellInjectorProvider)
class RellParsingTest {
	@Inject
	extension ParseHelper<Model> parseHelper
	@Inject extension ValidationTestHelper

// Check initialization byte_array
	@Test
	def void testInitValueToByteArray() {
		assertParsingTrue('''
			class foo {
			    ba : byte_array = x"0373599a61cc6b3bc02a78c34313e1737ae9cfd56b9bb24360b437d469efdf3b15";
			}		
		''')
	}

// Check initialization pubkey
	@Test
	def void testInitValueToPubkey() {
		assertParsingTrue('''
			class foo {
			    pb : pubkey = x"0373599a61cc6b3bc02a78c34313e1737ae9cfd56b9bb24360b437d469efdf3b15";
			}		
		''')
	}

// Check create tuple with named fields and two values 
	@Test
	def void testCreateSimpleTupleTwoValues() {
		assertParsingTrue('''
			operation op() {
				 val test_tuple: (text, integer)  = ("Bill", 38);
			}
		''')
	}

// Check create tuple with named fields and two values 
	@Test
	def void testCreateSimpleNamedTupleTwoValues() {
		assertParsingTrue('''
			operation op() {
				 val test_tuple: (name:text, age:integer)  = (name="John", age=18);
			}
		''')
	}

// Check create nested tuple 
	@Test
	def void testCreateNestedTuple() {
		assertParsingTrue('''
			operation op() {
					 val test_tuple: (text, (integer, boolean))  = ("Bill", (38, true));
			}
		''')
	}

// Check create named nested tuple 
	@Test
	def void testCreateNamedNestedTuple() {
		assertParsingTrue('''
			operation op() {
					 val test_tuple: (name: text, (age : integer, active : boolean))  = (name = "Bill", (age = 38, active = true));
			}
		''')
	}

// Check return tuple of reference types of values
	@Test
	def void testAssignTupleWithExplicitValues() {
		assertParsingTrue('''
			class city { name: text;}
			class person { name: text; age : integer; homeCity: city; workCity: city;}
			operation o() { 
			    val test_tuple : (homeCity : city, workCity : city) = person @ {.name == "Bob"} (.homeCity, .workCity);
			}
		''')
	}

// Check tuple of two values from at expression
	@Test
	def void testSimpleTuple() {
		assertParsingTrue('''
				operation op() {
			 val u: (integer,boolean, (boolean,boolean))=(100,true, (true,false));
			}
		''')
	}

// Check tuple of three values from at expression 
	@Test
	def void testTupleThreeValues() {
		assertParsingTrue('''
			class company { name; address : name; type : integer; }
			class user { name; company; }
			operation op() {
			    val u = user @ { .name == 'Bob' } ( .company.name, .company.address, .company.type );
			}
		''')
	}

// Check tuple of three values from at expression
	@Test
	def void testNestedTupleTwoTypes() {
		assertParsingTrue('''
			class company { name; address : name; type : integer;}
			class user { name; company; }
			operation op() {
			    val u = user @ { .name == 'Bob' } ( .company.name, .company.address );
			}
		''')
	}

// Check record declaration 
	@Test
	def void testRecordDeclaration() {
		assertParsingTrue('''
			record foo { k : pubkey; i : integer; name: text; }
			operation o(){
					val name = 'Bob';
					val address = 'New York';
					val u = foo(name, address);
					val u2 = foo(address, name); // Order does not matter - same record object is created.	
			}
		''')
	}

// Check if attribute type is not specified, it will be the same as attribute name 
	@Test
	def void testAttributeTypeAsAttributeName() {
		assertParsingTrue(''' 
			class test1 { id : guid; }
			class test2 { test1; }
		''')
	}

	@Test
	def void testIndexWithAttributeDefinition() {
		assertParsingTrue(''' 
			class test { index testIndex : text; }
		''')
	}

// Check default values for attribute
	@Test
	def void testDefaultAttributeValue() {
		assertParsingTrue(''' 
			class test { testText: text = 'test_text'; }
		''')
	}

// Check set default attribute value via at-operator 
	@Test
	def void testDefaultAttributeValueWithAtOperator() {
		assertParsingTrue(''' 
			class version { id : pubkey; value: integer; }
			class model { name: text; version: version = version@{}; }
		''')
	}

// Check set default attribute value via at-operator with 'where' part
	@Test
	def void testDefaultAttributeValueWithAtOperatorWherePart() {
		assertParsingTrue(''' 
			class version { id : pubkey; value: integer; }
			class model { name: text; version: version = version@{.id == x'0123abcd'};}
		''')
	}

	@Test
	def void testDefaultAttributeValueWithAtOperatorWherePartAndPubkey() {
		assertParsingTrue(''' 
			class version { id : pubkey; value: integer; }
			class model { name: text; version: version = version@{.id == x'0123abcd'};
			}
		''')
	}

// Check set default attribute value via at-operator that return value from 'what' part
	@Test
	def void testDefAttribValWithAtOperatorReturnWhatPart() {
		assertParsingTrue(''' 
			class version { id : pubkey; value: integer; }
			class model { name: text; version: integer = version@{.id == x'0123abcd'}(version.value); }
		''')
	}

// Check default attribute value via at-operator that return value by member access
	@Test
	def void testDefAttribValWithAtOperatorReturnMemberAccess() {
		assertParsingTrue(''' 
			class version { id : pubkey; value: integer; }
			class model { name: text; version : integer = version@{.id == x'0123abcd'}.value; }
		''')
	}

// Check that a class can have the 'key' clause after an attribute definition
	@Test
	def void testKeyAfterAttributeDefinition() {
		assertParsingTrue(''' 
			class test { testKey : text; key testKey; }
		''')
	}

// Check that a class can have the 'key' clause with an attribute definition	
	@Test
	def void testKeyWithAttributeDefinition() {
		assertParsingTrue(''' 
			class test {
				key testKey : text;
			}
		''')
	}

// Check that a class can have the composite "key" clause with multiple attributes in definition
	@Test
	def void testCompositeKeyWithAttributeDefinition() {
		assertParsingTrue('''
			class test {
				key firstField : text, secondField : text;
			}	
		''')
	}

// Check that a class can have the composite "key" clause with multiple attributes after their definition
	@Test
	def void testCompositeKeyAfterAttributeDefinition() {
		assertParsingTrue('''
			class test { firstField : text; secondField : text; key firstField, secondField; }
		''')
	}

// Check that a class can have the 'index' clause after an attribute definition
	@Test
	def void testIndexAfterAttributeDefinition() {
		assertParsingTrue(''' 
			class test { testIndex : text; index testIndex; }
		''')
	}

// Check that a class can have the 'index' clause with an attribute definition
	@Test
	def void testIndexWihAttributeDefiniton() {
		assertParsingTrue(''' 
			class test { index testIndex : text; }
		''')
	}

// Check that a class can have the composite "index" clause with multiple attributes in definition
	@Test
	def void testCompositeIndexWithAttributeDefinition() {
		assertParsingTrue('''
			class test { index firstField : text, secondField : text; }
		''')
	}

// Check that a class can have the composite composite "index" clause with multiple attributes after their definition
	@Test
	def void testCompositeIndexAfterAttributeDefinition() {
		assertParsingTrue('''
			class test { firstField : text; secondField : text; index firstField, secondField; }
		''')
	}

// Check an attribute, that has reference type to a class, as index clause	
	@Test
	def void testIndexOnAttributeWithRefType() {
		assertParsingTrue('''
			class test1 {}
			class test2 { index attrTest1 : test1; }
		''')
	}

// Check the 'mutable' keyword to an attribute	
	@Test
	def void testMutableToAttribute() {
		assertParsingTrue('''
			class test {
				mutable firstField : text;
			}	
		''')
	}

// Check creating the object of a class within 'operation' 	
	@Test
	def void testCreateObjectWithinOperation() {
		assertParsingTrue('''
			class test {a: text; b: text; c : text; key a; index b; }
			operation createTest() {
			    create test(a = 'akey', b = 'btext', c = 'ctext');
			}	
		''')
	}

// Check operation parameters
	@Test
	def void testOperationMustProvideParameters() {
		assertParsingTrue('''
			class test {a: text; b: text; c : text; key a; index b; }
			operation createTest(aParameter : text, bParameter : text, cParameter : text) {
			    create test(a=aParameter, b=bParameter, c=cParameter);
			}
		''')
	}

// Check assign a value of returning 'create' statement to 'val' within 'operation'	
	@Test
	def void testAssignValueFromCreateStatment() {
		assertParsingTrue('''
			class test {a: text; b: text; c : text; key a; index b; }
			operation createTest() {
			   val newTest =  create test(a = 'akey', b = 'btext', c = 'ctext');
			}
		''')
	}

// Check creating the object of a class with default values of attributes within 'operation' 	
	@Test
	def void testCreateObjectDefaultValuesWithinOperation() {
		assertParsingTrue('''
			class test {a: text='akey'; b: text='btext'; c : text='ctext'; key a; index b; }
			operation createTest() {
			    create test();
			}
		''')
	}

// Check '@'(exactly one) cardinality with Where-part '{}'
	@Test
	def void testExactlyOneCardinalityWherePart() {
		assertParsingTrue('''
			class test {field: text; key field; }
			operation o() { 
			    val t = test @ {.field == 'some_text'};
			}
		''')
	}

// Check '@*'(zero or more) cardinality with Where-part '{}'
	@Test
	def void testZeroOrMoreCardinalityWherePart() {
		assertParsingTrue('''
			class test {field: text; key field; }
			operation o() { 
			    val t = test @* {.field == 'some_text'};
			}
		''')
	}

	@Test
	def void testVarAndValOperation() {
		assertParsingTrue('''
			operation o() { val x = 1; var y = 1; }
		''')
	}

// Check '@*'(zero or one, fails if more than one found) cardinality with Where-part '{}'
	@Test
	def void testZeroOrMoreFailCardinalityWherePart() {
		assertParsingTrue('''
			class test {field: text; key field; }
			operation o() { 
			    val t = test @? {.field == 'some_text'};
			}
		''')
	}

// Check '@*'(one or more) cardinality with Where-part '{}'
	@Test
	def void testOneOrMoreCardinalityWherePart() {
		assertParsingTrue('''
			class test {field: text; key field; }
			operation o() { 
			    val t = test @+ {.field == 'some_text'};
			}
		''')
	}

// check create new object with explicit attributes initialization in 'create' statement
	@Test
	def void testCreateStatementWithExplicitAttributeInit() {
		assertParsingTrue('''
			class foo { id : integer; name : text; }
			operation op() {
				create foo(id = 1, name = 'test');
				create foo(name = 'test', id = 1);
			}
		''')
	}

// check create new object with implicit attributes initialization in 'create' statement
	@Test
	def void testCreateStatementWithImplicitAttributeInit() {
		assertParsingTrue('''
			class foo { id : integer; name1 : text; }
			
			operation op() {
				create foo(1,'test');
			}
		''')
	}

// check nested 'create' statement with explicit attributes initialization
	@Test
	def void testNestedCreateStatementWithExplicitAttributeInit() {
		assertParsingTrue('''
			class foo { id : integer; name : text; }
			class bar { id : integer; name : text; f : foo; }
			operation op() {
				create bar (id = 1, name = 'test', create foo(id = 1, name = 'test'));
			}
		''')
	}

// check nested 'create' statement with implicit attributes initialization
	@Test
	def void testNestedCreateStatementWithImlicitAttributeInit() {
		assertParsingTrue('''
			class foo { id : integer; name : text; }
			class bar { id : integer; name : text; f : foo; }
			operation op() {
				create bar (1, 'test', create foo(1, 'test'));
			}
		''')
	}

// check arbitrary order of 'create' statement parameters with explicit attributes initialization
	@Test
	def void testExplicitArbitraryOrderOfParameters() {
		assertParsingTrue('''
			class foo { id : integer; name1 : text; }
			operation op() {
				create foo(.id = 1, .name1 = 'test');
				create foo(.name1 = 'test', .id = 1);
			}
		''')
	}

// check arbitrary order of 'create' statement parameters with implicit attributes initialization
	@Test
	def void testImplicitArbitraryOrderOfParameters() {
		assertParsingTrue('''
			class foo { id : integer; name : text; }
			operation op() {
				create foo(1, 'test');
				create foo('test', 1);
			}
		''')
	}

// check at-operator within 'create' statement as parameter
	@Test
	def void testAtOperatorAsParameterInCreate() {
		assertParsingTrue('''
			class foo { id : integer; name : text; }
			class bar { id : integer; name1 : text;	f : foo; }
			operation op() {
				create bar (1, 'test', foo @ {.name == 'foo'});
			}
		''')
	}

// check alias in 'where' part of at-operator within operation
	@Test
	def void testAliasWherePartWithinOperation() {
		assertParsingTrue('''
			class foo { pubkey; name; }
			operation op() {
			    val foo_obj = (f: foo) @{f.pubkey == x'0123abcd'};    
			}
			
		''')
	}

// check alias in 'where' and 'what' part of at-operator within operation 
	@Test
	def void testAliasWhatPartWithinOperation() {
		assertParsingTrue('''
			class foo { pubkey; name; }
			operation op() {
			    val foo_name = (f: foo) @{f.pubkey == x'0123abcd'}(f.name);    
			}
		''')
	}

// check explicit reference to a class variable in 'where' part within operation
	@Test
	def void testExplicitRefWherePart() {
		assertParsingTrue('''
			class foo { key k: integer; name; }
			operation op() {
			    val foo = foo @{.k == 122};    
			}
		''')
	}

// check explicit reference to a class variable in 'what' part within operation
	@Test
	def void testExplicitRefWhatPart() {
		assertParsingTrue('''
			class foo { key k: integer; name; }
			operation op() {
			    val foo = foo @{.k == 122}(.name);    
			}
		''')
	}

// check simple update operation (short expression to access to class members)
	@Test
	def void testUpdateOperationShortAccess() {
		assertParsingTrue('''
			class foo { key k: integer; mutable name; }
			operation op() {
			    update foo @{.k == 122}(name = "new_name");    
			}
		''')
	}

// check simple update operation (full expression to access to class members)
	@Test
	def void testUpdateOperationFullAccess() {
		assertParsingTrue('''
			class foo { key k: integer; mutable name; }
			operation op() {
			    update foo @{foo.k == 122}(name = "new_name");    
			}
		''')
	}

// check pass val variable to where part of at expression 
	@Test
	def void testUpdateOperationValInWherePart() {
		assertParsingTrue('''
			class foo { key k: integer; mutable name; }
			operation op() {
			  val k = 122;
			  update foo @{.k == k}(name = "new_name");    
			}
		''')
	}

// check update operation with alias
	@Test
	def void testUpdateOperationWithAlias() {
		assertParsingTrue('''
			class country { name: text; }
			class city { name: text; country; }
			class person { name: text; homeCity: city; workCity: city; mutable score: integer; }
			operation o() { 
			            update p: person (c1: city, c2: city) @ {
			                p.homeCity.name == c1.name,
			                p.workCity.name == c2.name,
			                c1.country.name == 'Germany',
			                c2.country.name == 'USA'
			            } ( score = 999 );
			         }
		''')
	}

// check alias in at-expression in update statement
	@Test
	def void testUpdateOperationAliasWithAssignFromAt() {
		assertParsingTrue('''
			class country { name: text; }
			class city { name: text; country; }
			class person { name: text; homeCity: city; workCity: city; mutable score: integer; }
			operation o() { update p1: person (p2: person) @ { p1.homeCity == p2.workCity } ( score = p1.score * 3 + p2.score ); }
		''')
	}

// check assign value from at-expression in update statement
	@Test
	def void testUpdateOperationWithAssignFromAt() {
		assertParsingTrue('''
			class default_score { name : text; value: integer; }
			class person { name: text; mutable score: integer = default_score@{}.value; }
			operation o() { update person @ {} (.score = default_score @{.name == "super_score"}.value); }
		''')
	}

// check assign value from at-expression in update statement
	@Test
	def void testAssesToVariableFromSelect() {
		assertParsingTrue('''
			class default_score { name : text; value: integer; }
			class person { name: text; mutable score: integer = default_score@{}.value; }
			
		''')
	}

// check query short form
	@Test
	def void testQueryShortForm() {
		assertParsingTrue('''
			query q(x: integer): integer = x * x;
		''')
	}

// check query full from
	@Test
	def void testQueryFullForm() {
		assertParsingTrue('''
			query q(x: integer): integer { return x * x; }
		''')
	}

// check return record from query
	@Test
	def void testReturnRecordWithinQuery() {
		assertParsingTrue('''
			record foo { i: integer; s: text; q: text = 'test'; }
			query q() { val s = 'Hello'; val q = 'Bye'; return foo(i = 123, q, s); }
		''')
	}

// check tuple return from query
	@Test
	def void testReturnTupleFromQuery() {
		assertParsingTrue(
			'''
				class company { name: text; }
				class user { firstName: text; lastName: text; company; }
				query q() {  return user @ { .firstName == 'Bill' } (.lastName, '' + (123,'Hello')); }
			'''
		)
	}

// list ''+ from at expression
	@Test
	def void testListFromAtExpression() {
		assertParsingTrue('''
			class company { name: text; }
			class user { firstName: text; lastName: text; company; }
			query q() {  return user @ { .firstName == 'Bill' } (.lastName, '' + list([1,2,3])); }
		''')
	}

// check list equal operators ===, !==, ==, !=
	@Test
	def void testListReturnFromQueryOne() {
		assertParsingTrue('''
			query q1() { var x: list<list<text>>; x = [['Hello', 'World']]; return x; }
			query q2() { val a: list<integer>? = [1,2,3]; return a === null; }
			query q3() { val a: list<integer>? = [1,2,3]; return a !== null; }
			query q4() { val a: list<integer>? = [1,2,3]; return a === [1,2,3]; }
			query q5() { val a: list<integer>? = [1,2,3]; return a !== [1,2,3]; }
			query q6() { val a: list<integer>? = [1,2,3]; val b = a; return a === b; }
			query q7() { val a: list<integer>? = [1,2,3]; val b = a; return a !== b; }
			query q8() { val a: list<integer>? = null; return a === null; }
			query q9() { val a: list<integer>? = null; return a !== null; }
			query q10() { val a: list<integer>? = null; return a === [1,2,3]; }
			query q11() { val a: list<integer>? = null; return a !== [1,2,3]; }
			query q12() { val a = [1, 2, 3]; val b = [1, 2, 3]; return a == b; }
			query q13() { val a = [1, 2, 3]; val b = [1, 2, 3]; return a != b; }
			query q14() { val a = [1, 2, 3]; val b = [1, 2, 3]; return a === b; }
			query q15() { val a = [1, 2, 3]; val b = [1, 2, 3]; return a !== b; }
			query q16() { val a = [1, 2, 3]; val b = a; return a === b; }
			query q17() { val a = [1, 2, 3]; val b = a; return a !== b; }
		''')
	}

// check list addAll, removeAll, containsAll
	@Test
	def void testListaddAllremoveAllcontainsAll() {
		assertParsingTrue('''
			query q1() { val x = list<integer?>(); x.addAll(list<integer>([123])); return ''+x; }
			query q2() { val x = list<integer?>(); x.addAll(list<integer?>([123,null])); return ''+x; }
			query q3() { val x = list<integer>([123,456]); x.removeAll(list<integer>([123])); return ''+x; }
			query q4() { val x = list<integer?>([123,456,null]); x.removeAll(list<integer>([123])); return ''+x; }
			query q5() { val x = list<integer?>([123,456,null]); x.removeAll(list<integer?>([123,null])); return ''+x; }
			query q6() { val x = list<integer>([123,456]); return x.containsAll(list<integer>([123])); }
			query q7() { val x = list<integer?>([123,456,null]); return x.containsAll(list<integer>([123])); }
			query q8() { val x = list<integer?>([123,456,null]); return x.containsAll(list<integer?>([123,null])); }
		''')
	}

// check list calculate
	@Test
	def void testListCalculate() {
		assertParsingTrue('''
			query q1() = list([1, 2, 3, 4, 5]).calculate(0) ;
			query q2() = list([1, 2, 3, 4, 5]).calculate(4) ;
			query q3() = list([1, 2, 3, 4, 5]).calculate(-1) ;
			query q4() = list([1, 2, 3, 4, 5]).calculate(5) ;
			query q5() = [1, 2, 3, 4, 5].calculate(0) ;
			query q6() = [1, 2, 3, 4, 5].calculate(4) ;
			query q7() = [1, 2, 3, 4, 5].calculate(-1) ;
			query q8() = [1, 2, 3, 4, 5].calculate(5) ;
		''')
	}

// check list clear, empty
	@Test
	def void testListClearEmpty() {
		assertParsingTrue('''
			query q1() { val x = [1, 2, 3]; x.clear(); return x; }
			query q2() = list<integer>().empty() ;
			query q3() = list<integer>([1]).empty() ;
			query q4() = list<integer>([1, 2, 3, 4, 5]).empty() ;
		''')
	}

	@Test
	def void testListSizeLen() {
		assertParsingTrue('''
			query q1() = list<integer>().size() ;
			query q2() = list([1]).size() ;
			query q3() = list([1, 2, 3, 4, 5]).size() ;
			query q4() = list<integer>().size() ;
			query q5() = list([1]).size() ;
			query q6() = list([1, 2, 3, 4, 5]).size() ;
		''')
	}

// check list from set
	@Test
	def void testListFromSet() {
		assertParsingTrue('''
			query q1() = list<integer>(list<integer>()) ;
			query q2() = list<integer>(set<integer>()) ;
			query q3() = list<integer?>(list<integer>()) ;
			query q4() = list<integer?>(list<integer?>()) ;
			query q5() = list<integer?>(set<integer>()) ;
			query q6() = list<integer?>(set<integer?>()) ;
		''')
	}

// check list with records
	@Test
	def void testListWithRecords() {
		assertParsingTrue('''
			record foo { x: integer; b: list<bar>; } record bar { s: list<text>; q: boolean; }
			query q1() { val f = foo(123, [bar(['Hello'], true)]); return f == foo(123, [bar(['Hello'], true)]); }
			query q2() { val l = ['Hello']; val f = foo(123, [bar(l, true)]);
			                l.add('Bye');
			                return f == foo(123, [bar(['Hello'], true)]); }
		''')
	}

// check simple create of set
	@Test
	def void testCreateSet() {
		assertParsingTrue('''
			query q1() = set<integer>() ;
			query q2() = set([123]) ;
			query q3() = set([123, 456, 789]) ;
			query q4() = set([1, 2, 3, 2, 3, 4, 5]) ;
			query q5() = set(list([123, 456, 789])) ;
		''')
	}

// check create set from list, set
	@Test
	def void testCreateSetFromListSet() {
		assertParsingTrue('''
			query q1() = set<integer>(list<integer>());
			query q2() = set<integer>(set<integer>());
			query q3() = set<integer?>(list<integer>());
			query q4() = set<integer?>(list<integer?>());
			query q5() = set<integer?>(set<integer>());
			query q6() = set<integer?>(set<integer?>());
		''')
	}

// check equals of set 
	@Test
	def void testSetEqualsOperator() {
		assertParsingTrue('''
			query q1() { val a = set([1, 2, 3]); val b = set([1, 2, 3]); return a == b; }
			query q2() { val a = set([1, 2, 3]); val b = set([1, 2, 3]); return a != b; }
			query q3() { val a = set([1, 2, 3]); val b = set([1, 2, 3]); return a === b; }
			query q4() { val a = set([1, 2, 3]); val b = set([1, 2, 3]); return a !== b; }
			query q5() { val a = set([1, 2, 3]); val b = a; return a === b; }
			query q6() { val a = set([1, 2, 3]); val b = a; return a !== b; }
		''')
	}

// check 'in' set 
	@Test
	def void testSetMethods() {
		assertParsingTrue('''
		query q() = set<integer>().str() ;
		query q() = set<integer>([1]).str() ;
		query q() = set<integer>([1, 2, 3, 4, 5]).str() ;
		
		
		query q() { val x = set<integer?>(); x.add(null); return ''+x; }
		query q() { val x = set<integer?>(); x.add(123); return ''+x; }
		query q() { val x = set<integer>([123]); x[0] = 456; return ''+x; }
		query q() { val x = set<integer?>([123,456,null]); x.removeAll(set<integer>([123])); return ''+x; }
		query q() { val x = set<integer>([123,456]); return x.containsAll(set<integer>([123])); }''')

	}

	def void testInSet() {
		assertParsingTrue('''
			query q1() = 123 in set([123, 456]);
			query q2() = 456 in set([123, 456]);
			query q3() = 789 in set([123, 456]);
			query q4() = 123 in set<integer>();
			
		''')
	}

// check contains, containsAll set 
	@Test
	def void testSetContains() {
		assertParsingTrue('''
			query q1() { val x = set<integer>([123]); return x.contains(123); }
			query q2() { val x = set<integer?>([123]); return x.contains(null); }
			query q3() { val x = set<integer?>([123]); x.add(null); return x.contains(null); }
			query q4() = set([1, 2, 3]).contains(1) ;
			query q5() = set([1, 2, 3]).contains(3) ;
			query q6() = set([1, 2, 3]).contains(5) ;
			query q7() { val x = set<integer?>([123]); return x.contains(123); }
			query q8() = list<integer>().containsAll(set<integer>()) ;
			query q9() = [1, 2, 3].containsAll(set([1, 2, 3])) ;
			query q10() = [1, 2, 3].containsAll(set([0])) ;
			query q11() = [1, 2, 3].containsAll(set([2])) ;
			query q12() = set<integer>().containsAll(list<integer>()) ;
			query q13() = set<integer>().containsAll(set<integer>()) ;
			query q14() = set<integer>([1, 2, 3]).containsAll([1, 2, 3]) ;
			query q15() = set<integer>([1, 2, 3]).containsAll(set([1, 2, 3])) ;
			query q16() = set<integer>([1, 2, 3]).containsAll([0]) ;
			query q17() = set<integer>([1, 2, 3]).containsAll([2]) ;
			query q18() = set<integer>([1, 2, 3]).containsAll(set([0])) ;
			query q19() = set<integer>([1, 2, 3]).containsAll(set([2])) ;
			query q20() = set<integer>([1, 2, 3]).containsAll([1, 3]) ;
			query q21() = set<integer>([1, 2, 3]).containsAll([0, 1]) ;
			query q22() = set<integer>([1, 2, 3]).containsAll([1, 2, 3, 4]) ;
		''')
	}

// check add, addAll set 
	@Test
	def void testSetAdd() {
		assertParsingTrue('''
			query q1() { val x = set<integer>(); x.add(123); return ''+x; }
			query q2() { val x = set<integer?>(); x.add(null); return ''+x; }
			query q3() { val x = set<integer?>(); x.add(123); return ''+x; }
			query q4() { val x = set([1, 2, 3]); val r = x.addAll(set<integer>()); return r+' '+x; }
			query q5() { val x = set([1, 2, 3]); val r = x.addAll(list<integer>()); return r+' '+x; }
			query q6() { val x = set([1, 2, 3]); val r = x.addAll(set<integer>([1, 2, 3])); return r+' '+x; }
			query q7() { val x = set([1, 2, 3]); val r = x.addAll(list<integer>([1, 2, 3])); return r+' '+x; }
			query q8() { val x = set([1, 2, 3]); val r = x.addAll(set<integer>([3, 4, 5])); return r+' '+x; }
			query q9() { val x = set([1, 2, 3]); val r = x.addAll(list<integer>([3, 4, 5])); return r+' '+x; }
			query q10() { val x = set([1, 2, 3]); val r = x.addAll([4, 5, 6]); return r+' '+x; }
		''')
	}

// check remove, removeAll set 
	@Test
	def void testSetRemove() {
		assertParsingTrue('''
			query q1() { val x = set([1, 2, 3]); val r = x.remove(1); return ''+r+' '+x; }
			query q2() { val x = set([1, 2, 3]); val r = x.remove(2); return ''+r+' '+x; }
			query q3() { val x = set([1, 2, 3]); val r = x.remove(3); return ''+r+' '+x; }
			query q4() { val x = set([1, 2, 3]); val r = x.remove(0); return ''+r+' '+x; }
			query q5() { val x = set([1, 2, 3]); val r = x.removeAll(set([0])); return ''+r+' '+x; }
			query q6() { val x = set([1, 2, 3]); val r = x.removeAll(set([1])); return ''+r+' '+x; }
			query q7() { val x = set([1, 2, 3]); val r = x.removeAll(set([2])); return ''+r+' '+x; }
			query q8() { val x = set([1, 2, 3]); val r = x.removeAll(set([3])); return ''+r+' '+x; }
			query q9() { val x = set([1, 2, 3]); val r = x.removeAll([0]); return ''+r+' '+x; }
			query q10() { val x = set([1, 2, 3]); val r = x.removeAll([2]); return ''+r+' '+x; }
			query q11() { val x = set([1, 2, 3]); val r = x.removeAll([1, 2, 3]); return ''+r+' '+x; }
			query q12() { val x = set([1, 2, 3]); val r = x.removeAll([1, 3]); return ''+r+' '+x; }
		''')
	}

// check set to list, list to set
	@Test
	def void testMapMethods() {
		assertParsingTrue('''
			query q() { val x = map<integer,text?>(); x[123]=null; return ''+x;}
			query q() = map<text,foo>() ;
			query q (x: integer): map<integer, text> = [x:'Bob',x*2:'Alice'];	
			query q() = map<text,integer>().calculate('Bob') ;
			query q() = ['Bob':123,'Alice':456].calculate('Bob') ;
		''')

	}

	@Test
	def void testListCreation() {
		assertParsingTrue(
			'''
			class TestClass{
				test:integer;
			}
			
			operation t1(){
				val t:list<integer> = [1,2,3];
				val t1:list<integer?> =[1,2,3];
			}'''
		)

	}

	def void testSetToListToSet() {
		assertParsingTrue('''
			query q1() { val x = set<integer>([123]); val y = list<integer?>(x); return ''+y; }
			query q2() { val x = set<integer?>([123]); val y = list<integer?>(x); return ''+y; }
			query q3() { val x = list<integer>([123]); val y = set<integer?>(x); return ''+y; }
			query q4() { val x = list<integer?>([123]); val y = set<integer?>(x); return ''+y; }
			query q5() { val x = set<integer>([123]); val y = set<integer?>(x); return ''+y; }
			query q6() { val x = set<integer?>([123]); val y = set<integer?>(x); return ''+y; }
		''')
	}

// check set with records
	@Test
	def void testSetWithRecords() {
		assertParsingTrue('''
			record foo1 { x: list<set<(a: text, b: integer)>>; }
			record foo2 { x: list<set<(q: text, integer)>>; }
			record foo3 { x: text; b: bar; } record bar { p: integer; q: integer; }
			record foo4 { x: integer; }
			query q1() { var s = set([foo3('ABC', bar(p=123,q=456))]); return s; }
			query q2() { var s = set([foo3('ABC', bar(p=123,q=456))]); return s.contains(foo3('ABC',bar(p=123,q=456))); } 
			query q3() { var s = set([foo4(123)]); return s; }
		''')
	}

// check set underline
	@Test
	def void testSetUnderline() {
		assertParsingTrue('''
			query q1() { val x = [1, 2, 3]; val r = x._set(0, 5); return ''+r+' '+x; }
			query q2() { val x = [1, 2, 3]; val r = x._set(1, 5); return ''+r+' '+x; }
			query q3() { val x = [1, 2, 3]; val r = x._set(2, 5); return ''+r+' '+x; }
			query q4() { val x = [1, 2, 3]; val r = x._set(-1, 5); return ''+r+' '+x; }
			query q5() { val x = [1, 2, 3]; val r = x._set(3, 5); return ''+r+' '+x; }
		''')
	}

// check empty, len, size of set 
	@Test
	def void testSetEmptylenSize() {
		assertParsingTrue('''
			query q1() = set<integer>().empty() ;
			query q2() = set<integer>([1]).empty() ;
			query q3() = set<integer>([1, 2, 3, 4, 5]).empty() ;
			query q4() = set<integer>().size() ;
			query q5() = set([1]).size() ;
			query q6() = set([1, 2, 3, 4, 5]).size() ;
			query q7() = set([1, 2, 3, 2, 3, 4, 5]).size() ;
			query q8() = set<integer>().len() ;
			query q9() = set([1]).len() ;
			query q10() = set([1, 2, 3, 4, 5]).len() ;
			query q11() = set([1, 2, 3, 2, 3, 4, 5]).len() ;
			query q12() = 1 in set([1, 2, 3]) ;
			query q13() = 3 in set([1, 2, 3]) ;
			query q14() = 5 in set([1, 2, 3]) ;
		''')
	}

// check set requireNotEmpty
	@Test
	def void testSetRequireNotEmpty() {
		assertParsingTrue('''
			query q1() { val x = set<integer>(); return requireNotEmpty(x); }
			query q2() { val x = set([123]); return requireNotEmpty(x); }
			query q3() { val x: set<integer>? = null; return requireNotEmpty(x); }
			query q4() { val x: set<integer>? = set<integer>(); return requireNotEmpty(x); }
			query q5() { val x: set<integer>? = set([123]); return requireNotEmpty(x); }
		''')
	}

// check map type compatible
	@Test
	def void testMapTypeCompatible() {
		assertParsingTrue('''
			query q1() { val x = map<integer,text>([123:'Hello']); val y = map<integer,text>(x); return ''+y; }
			query q2() { val x = map<integer,text>([123:'Hello']); val y = map<integer?,text>(x); return ''+y; }
			query q3() { val x = map<integer?,text>([123:'Hello']); val y = map<integer?,text>(x); return ''+y; }
			query q4() { val x = map<integer,text>([123:'Hello']); val y = map<integer,text?>(x); return ''+y; }
			query q5() { val x = map<integer,text?>([123:'Hello']); val y = map<integer,text?>(x); return ''+y; }
			query q6() { val x = map<integer,text>([123:'Hello']); val y = map<integer?,text?>(x); return ''+y; }
			query q7() { val x = map<integer?,text>([123:'Hello']); val y = map<integer?,text?>(x); return ''+y; }
			query q8() { val x = map<integer,text?>([123:'Hello']); val y = map<integer?,text?>(x); return ''+y; }
			query q9() { val x = map<integer?,text?>([123:'Hello']); val y = map<integer?,text?>(x); return ''+y; }
		''')
	}

// check map type putAll compatible
	@Test
	def void testMapTypePutAllCompatible() {
		assertParsingTrue('''
			query q1() { val x = map<integer?,text>([123:'Hello']); return x[null];}
			query q2() { val x = map<integer?,text>([123:'Hello']); x.put(null,'World'); return x[null];}
			query q3() { val x = map<integer?,text?>([123:'Hello']); return x[null];}
			query q4() { val x = map<integer?,text?>([123:'Hello']); x.put(null,'World'); return x[null];}
			query q5() { val x = map<integer,text>(); x.put(123,'Hello'); return ''+x;}
			query q6() { val x = map<integer,text>(); x[123]='Hello'; return ''+x;}
			query q7() { val x = map<integer?,text>(); x.put(123,'Hello'); return ''+x;}
			query q8() { val x = map<integer?,text>(); x.put(null,'Hello'); return ''+x;}
			query q9() { val x = map<integer?,text>(); x[123]='Hello'; return ''+x;}
			query q10() { val x = map<integer?,text>(); x[null]='Hello'; return ''+x;}
			query q11() { val x = map<integer,text?>(); x.put(123,'Hello'); return ''+x;}
			query q12() { val x = map<integer,text?>(); x.put(123,null); return ''+x;}
			query q13() { val x: map<integer,text> = map<integer,text>([123:'Hello']); return ''+x; }
			query q14() { val x = map<integer,text>(); x.putAll(map<integer,text>([123:'Hello'])); return ''+x;}
			query q15() { val x = map<integer?,text>(); x.putAll(map<integer,text>([123:'Hello'])); return ''+x;}
			query q16() { val x = map<integer?,text>(); x.putAll(map<integer?,text>([123:'Hello'])); return ''+x;}
			query q17() { val x = map<integer,text?>(); x.putAll(map<integer,text>([123:'Hello'])); return ''+x;}
			query q18() { val x = map<integer,text?>(); x.putAll(map<integer,text?>([123:'Hello'])); return ''+x;}
			query q19() { val x = map<integer?,text?>(); x.putAll(map<integer,text>([123:'Hello'])); return ''+x;}
			query q20() { val x = map<integer?,text?>(); x.putAll(map<integer?,text>([123:'Hello'])); return ''+x;}
			query q21() { val x = map<integer?,text?>(); x.putAll(map<integer,text?>([123:'Hello'])); return ''+x;}
			query q22() { val x = map<integer?,text?>(); x.putAll(map<integer?,text?>([123:'Hello'])); return ''+x;}
		''')
	}

	@Test
	def void testSimpleDefList() {
		assertParsingTrue('''
			class TestClass{ test:integer; }	
			operation t1(){
				val t:list<integer>;
				val t1:list<integer?>;
				val t2:list<TestClass>;
				
			}
		''')
	}

	@Test
	def void testVarRef() {
		assertParsingTrue('''
			operation o(){
				val t:integer;
				t[0]=1;
				val x = list<integer>([123]); 
				x[0] = 456;
				val x = list<integer?>(); 
				x.add(null);
			}
			
		''')
	}

// check simple declaration of function 
	@Test
	def void testsimpleFunctionDeclaration() {
		assertParsingTrue('''
			function f(x: integer): integer = x * x;
		''')
	}

// check update statement in function
	@Test
	def void testUpdateStatementInFunction() {
		assertParsingTrue('''
			class user { name: text; mutable score: integer; }
			function f(name: text, s: integer): integer { update user @ { name } ( score += s ); return s; } query q() = f('Bob', 500) ;
		''')
	}

	@Test
	def void testCreateInOperation() {
		assertParsingTrue('''
			class user { key pubkey; index username: text; firstName: text; lastName: text; email: text; }
			    operation add_user (admin_pubkey: integer, pubkey, username: text, firstName: text, lastName: text, email: text) {
			           create user (pubkey, username, firstName, lastName, email);
			    }
		''')
	}

	@Test // This test will need to fail, but it's passed
	def void testDefaultVariableName() {
		assertParsingTrue('''
			operation test(){ var integer=5; var i:integer=integer; }
		''')

	}

	@Test
	def void testDefaultVariableNameInsideTheOperation() {
		assertParsingTrue('''	
			operation test (pubkey) { var test:pubkey = i; }
		''')
	}

	@Test // This test will need to fail, but it's passed
	def void testDefaultVariableNameInsideTheOperation1() {
		assertParsingTrue('''	
			operation test (pubkey) { var test:pubkey = i; }
		''')
	}

	@Test // This test will need to fail, but it's passed
	def void testAliases() {
		assertParsingTrue('''
			class Test{ t:text; }
			class Test1{ t1:text; }
			class Test3{ t2:text; }
			operation o(){ val op=(a:Test,b:Test7)@{a.t=="rrrr"};}
		''')

	}

	def void assertParsingTrue(String codeSnippet) {
		val result = parseHelper.parse(codeSnippet)
		Assert.assertNotNull(result)
		result.assertNoErrors
	}

}
