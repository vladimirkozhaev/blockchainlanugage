grammar org.blockchain.rell.Rell with org.eclipse.xtext.common.Terminals

generate rell "http://www.blockchain.org/rell/Rell"

Model:
	entities+=(ClassDefinition | Record)*
	operations+=(Operation | Query)*;

ClassDefinition:
	'class' name=ID ('extends' superType=[ClassDefinition])? '{'
	attributeListField+=AttributeListField*
	'}';

Record:
	'record' name=ID ('extends' superType=[ClassDefinition])? '{'
	attributeListField+=AttributeListField*
	'}';

AttributeListField:
	mutable=Mutable? key=Key? index=Index? attributeList+=RelAttrubutesList ';';

Operation:
	"operation" name=ID "(" parameters=RelAttrubutesList? ")" "{" statements+=Statement* "}";

Query:
	"query" name=ID '(' parameters=RelAttrubutesList? ')'
	(DOUBLE_QUOTE type=TypeReference)?
	(('=' returnExr=Expression ';') |
	('{'
	statements+=Statement*
	'return' returnExr=Expression ';'
	'}'));


Statement:
	(relation=Relational | variable=OperationVariable|varInitiation=VarInitiation) ';';

VarInitiation:
	VariableDeclarationRef ('=' expression=Expression)?
;

OperationVariable:
	assessModificator=(Var | Val) variable=Variable;

Variable:
	name=VariableDeclaration (('=' expression=Expression)?);

Relational:
	Update | Delete | Create | AtOperator;

Update:
	'update' entity=[ClassDefinition] Ampersand '{' conditions+=Expression (',' conditions+=Expression)* '}' '('
	createWhatPart+=CreateWhatPart (','		
	createWhatPart+=CreateWhatPart)*
	')';

Delete:
	'delete' entity=[ClassDefinition] Ampersand '{' conditions+=Expression (',' conditions+=Expression)* '}';


Create:
	'create' (entity=[ClassDefinition]) '(' (createWhatPart+=CreateWhatPart (','
	createWhatPart+=CreateWhatPart)*)? ')';

CreateRecord:
	(entity=[Record]) '(' (createWhatPart+=CreateWhatPartNoVariable (','
	createWhatPart+=CreateWhatPartNoVariable)*)? ')';

CreateWhatPart:
	(varDeclRef=VariableDeclarationRef '=')?
	condition+=Expression;

CreateWhatPartNoVariable:
	(varDeclRef=ID '=')?
	condition+=Expression;

AtOperator:
	(tableNameWithAlias+=TableNameWithAlias | '(' tableNameWithAlias+=TableNameWithAlias (','
	tableNameWithAlias+=TableNameWithAlias)* ')') Ampersand (ampersandModificator=AmpersandModificator?) '{'
	(conditions+=Expression (',' conditions+=Expression)*)? '}' ((tupleValue=TupleValue?) | ('.'
	variableDeclarationRef=VariableDeclarationRef));

TupleValue:
	'(' members+=TupleValueMember (',' tuplePart+=TupleValueMember)* ')';

ListCreation:
	'[' arguments=Arguments ']' ('.' LIST_METHOD listMethodArguments+=ArgumentsInBrackets)*;

MapCreation:
	'[' mapPart+=MapCreationPart (',' mapPart+=MapCreationPart)* ']' ('.' MAP_METHOD listMethodArguments+=ArgumentsInBrackets)*
;

NewListCreation:
	List {NewListCreation} (specification=ListSpecification?) 
	'(' 
		(
			(
				listCreation=ListCreation|
				newListCreation=NewListCreation|
				newSetCreation=NewSetCreation
			)?
		) 
		')' ('.' LIST_METHOD arguments+=ArgumentsInBrackets)*;

NewMapCreation:
	Map {NewMapCreation	}specification=MapSpecification? '(' (creation=ListCreation?) ')' ('.' MAP_METHOD arguments+=Arguments )*;

NewSetCreation:
	Set {NewSetCreation} (specification=ListSpecification?) 
	'(' 
		(
			(listCreation=ListCreation|newListCreation=NewListCreation|newSetCreation=NewSetCreation)?
		) 
	')' 
	('.' LIST_METHOD arguments+=ArgumentsInBrackets )*;


TupleValueMember:
	(name=ValuableID '=')? value=Expression;

ClassMemberDefinition:
	(classRef=ClassRef)? "." variableDeclarationRef=VariableDeclarationRef;

ClassRef:
	value=[TableNameWithAlias];

TableNameWithAlias:
	{ClassRefDecl} (name=ID DOUBLE_QUOTE classDef=[ClassDefinition]) |
	{JustNameDecl} name=[ClassDefinition];

VariableDeclarationRef:
	decl=[VariableDeclaration|ValuableID] (accesToList=AccessToList?)  ('.' (part+=[VariableDeclaration|ValuableID]|call=MethodCall))*;

MethodCall:name=MethodName arguments=ArgumentsInBrackets;

Arguments:listPart+=Expression (','  listPart+=Expression)*;

ArgumentsInBrackets: '(' arguments=Arguments? ')';

MethodName:
	LIST_METHOD
;
	

AccessToList:
	'[' expr=Expression ']';


Expression:
	or=Or;

Or returns Expression:
	And ({Or.left=current} "or" right=And)*;

And returns Expression:
	Equality ({And.left=current} "and" right=Equality)*;

Equality returns Expression:
	Comparison ({Equality.left=current} op=(EQUALS | NOT_EQUALS|EQUALSS|NOT_EQUALSS)
	right=Comparison)*;

Comparison returns Expression:
	PlusOrMinus ({Comparison.left=current} op=(MORE_EQUAL | LESS_EQUAL | MORE | LESS)
	right=PlusOrMinus)*;

PlusOrMinus returns Expression:
	MulOrDiv (({Plus.left=current} PlusChar | {Minus.left=current} MinusChar)
	right=MulOrDiv)*;

MulOrDiv returns Expression:
	Primary ({MulOrDiv.left=current} op=(MulChar | DivChar)
	right=Primary)*;

Primary returns Expression:
	'(' Expression ')' |
	{Not} "not" expression=Primary |
	Atomic;

Atomic returns Expression:
	{IntConstant} value=IntWithMinus |
	{StringConstant} value=STRING |
	{ByteArrayConstant} value=BYTE_ARRAY_VALUE |
	{BoolConstant} value=('true' | 'false') |
	{SelectOp} value=AtOperator |
	{MemberDefinition} value=ClassMemberDefinition |
	{CreateAtom} value=Create |
	{CreateRecordAtom} value=CreateRecord
	| {TupleRes} value=TupleValue
	| {ListCreation} value=ListCreation
	| {MapCreation} value=MapCreation
	| {NewLCreation} value=NewListCreation
	| {NewSCreation} value=NewSetCreation
	| {NewMCreation} value=NewMapCreation
	| {TheNull} value=NULL
	|{VariableRef} value=VariableDeclarationRef;


MapCreationPart:exprKey=Expression DOUBLE_QUOTE exprValue=Expression;

RelAttrubutesList:
	value+=Variable (',' value+=Variable)*;

VariableDeclaration:
	name=ValuableID ((DOUBLE_QUOTE type=TypeReference)?);
	
TupleVarDeclaration:
	(name=ValuableID DOUBLE_QUOTE)? type=TypeReference;

TypeReference:
	primitive=PrimitiveType | entityType=ClassType | tuple=TupleType | list=ListType|set=SetType|map=MapType;

ListType:
	List ListSpecification;
SetType:
	Set ListSpecification;

MapType:
	Map MapSpecification;
ListSpecification:
	LESS listType=TypeReference (QuestionChar?) MORE;
	
MapSpecification:
	LESS keySpec=TypeReference (QuestionChar?) ',' valSpec=TypeReference (QuestionChar?) MORE;

TupleType:
	'(' varDecl+=TupleVarDeclaration (',' varDecl+=TupleVarDeclaration)* ')';

ClassType:
	type=[ClassDefinition];

PrimitiveType:
	Text | Tuid | Pubkey | Name | Timestamp | Integer | Json | ByteArray | Boolean;

ValuableID:
	PrimitiveType | ID;

AmpersandModificator:
	PlusChar | MulChar | QuestionChar;

IntWithMinus:MinusChar? INT;

Name:
	'name';

Pubkey:
	'pubkey';

Timestamp:
	'timestamp';

 Tuid:
	'tuid';

Boolean:
	'boolean';

Json:
	'json';

Integer:
	'integer';

Text:
	'text';

ByteArray:
	'byte_array';

List:
	'list';

Map:'map';

Set:
	'set';

Key:
	'key';

Index:
	'index';

Mutable:
	'mutable';

Var:
	'var';

Val:
	'val';

Ampersand:
	'@';

QuestionChar:
	'?';

PlusChar:
	'+';

MinusChar:
	'-';

MulChar:
	'*';

DivChar:
	'/';
	
LIST_METHOD:
	"add"|"addAll"|"contains"|"containsAll"|"removeAll"|"calculate"|"sub"|"size"|"str"|"remove"|"removeAt"|"clear"|"empty"
	;
	
MAP_METHOD:"empty"|"size"|"contains"|"get"|"str"|"clear"|"put"|"putAll"|"remove"|"keys"|"values";	
//terminal SET_METHOD:LIST_METHOD;
	
terminal EQUALS:
	'==';
terminal EQUALSS:
	'===';

terminal NOT_EQUALS:
	'!=';
	
terminal NOT_EQUALSS:
	'!==';

terminal MORE_EQUAL:
	'>=';

terminal LESS_EQUAL:
	'<=';

terminal MORE:
	'>';

terminal LESS:
	'<';

terminal DOUBLE_QUOTE:
	':'
;


terminal NULL:
	'null';

terminal BYTE_ARRAY_CHAR:
	'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D'
	| 'E' | 'F';

terminal BYTE_ARRAY_PAIR:
	BYTE_ARRAY_CHAR BYTE_ARRAY_CHAR;

terminal BYTE_ARRAY_VALUE:
	'x' (('\'' BYTE_ARRAY_PAIR* '\'') | ('"' BYTE_ARRAY_PAIR* '"'));

