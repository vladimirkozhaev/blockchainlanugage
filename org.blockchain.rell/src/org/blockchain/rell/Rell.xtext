grammar org.blockchain.rell.Rell with org.eclipse.xtext.common.Terminals

generate rell "http://www.blockchain.org/rell/Rell"

Model:
	entities+=ClassDefinition*
	operations+=Operation*;

ClassDefinition:
	'class' name=ID ('extends' superType=[ClassDefinition])? '{'
	attributeListField+=AttributeListField*
	'}';

AttributeListField:
	mutable=Mutable? key=Key? index=Index? attributeList+=RelAttrubutesList ';';

Operation:
	"operation" name=ID "(" parameters=RelAttrubutesList? ")" "{" statements+=Statement* "}";

Statement:
	(relation=Relational | variable=OperationVariable) ';';

OperationVariable:
	assessModificator=(Var | Val) variable=Variable;

Variable:
	name=VariableDeclaration (('=' expression=Expression)?);

Relational:
	Update | Delete | Create | AtOperator;

Update:
	'update' entity=[ClassDefinition] '(' conditions+=Expression* ')' '{' variableList+=VariableInit
	(',' variableList+=VariableInit*)? '}';

Delete:
	'delete' entity=[ClassDefinition] '(' conditions+=Expression (',' conditions+=Expression)* ')';

Create:
	'create' entity=[ClassDefinition] '(' (createWhatPart+=CreateWhatPart  (','
	createWhatPart+=CreateWhatPart)*)? ')';

CreateWhatPart:
	(varDeclRef=VariableDeclarationRef '=')?
	condition+=Expression;

AtOperator:
	(tableNameWithAlias+=TableNameWithAlias | '(' tableNameWithAlias+=TableNameWithAlias (','
	tableNameWithAlias+=TableNameWithAlias)* ')') Ampersand ampersandModificator=AmpersandModificator? '{'
	conditions+=Expression (',' conditions+=Expression)* '}';

ClassMemberDefinition:
	classRef=ClassRef "." variableDeclarationRef=VariableDeclarationRef;

ClassRef:
	value=[TableNameWithAlias];

TableNameWithAlias:
	{ClassRefDecl} (name=ID ':' classDef=[ClassDefinition]) |
	{JustNameDecl} name=[ClassDefinition];

VariableDeclarationRef:
	decl=[VariableDeclaration|ValuableID];

VariableInit:
	name=[VariableDeclaration] '=' expression=Expression;

Expression:
	or=Or;

Or returns Expression:
	And ({Or.left=current} "or" right=And)*;

And returns Expression:
	Equality ({And.left=current} "and" right=Equality)*;

Equality returns Expression:
	Comparison ({Equality.left=current} op=("==" | "!=")
	right=Comparison)*;

Comparison returns Expression:
	PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<")
	right=PlusOrMinus)*;

PlusOrMinus returns Expression:
	MulOrDiv (({Plus.left=current} PlusChar | {Minus.left=current} MinusChar)
	right=MulOrDiv)*;

MulOrDiv returns Expression:
	Primary ({MulOrDiv.left=current} op=(MulChar | DivChar)
	right=Primary)*;

Primary returns Expression:
	'(' Expression ')' |
	{Not} "not" expression=Primary |
	Atomic;

Atomic returns Expression:
	{IntConstant} value=INT |
	{StringConstant} value=STRING |
	{BoolConstant} value=('true' | 'false') |
	{VariableRef} value=[VariableDeclaration|ValuableID] |
	{SelectOp} value=AtOperator |
	{MemberDefinition} value=ClassMemberDefinition|
	{CreateAtom} value=Create;

RelAttrubutesList:
	value+=Variable (',' value+=Variable)*;

VariableDeclaration:
	name=ValuableID ((':' type=TypeReference)?);

TypeReference:
	primitive=PrimitiveType | entityType=ClassType;

ClassType:
	type=[ClassDefinition];

PrimitiveType:
	Text | Tuid | Pubkey | Name | Timestamp | Integer | Json | ByteArray | Boolean;

ValuableID:
	PrimitiveType | ID;

AmpersandModificator:
	PlusChar | MulChar | QuestionChar;

Name:
	'name';

Pubkey:
	'pubkey';

Timestamp:
	'timestamp';

Tuid:
	'tuid';

Boolean:
	'bool';

Json:
	'json';

Integer:
	'integer';

Text:
	'text';

ByteArray:
	'byte_array';

List:
	'list';

Key:
	'key';

Index:
	'index';

Mutable:
	'mutable';

Var:
	'var';

Val:
	'val';

Ampersand:
	'@';

QuestionChar:
	'?';

PlusChar:
	'+';

MinusChar:
	'-';

MulChar:
	'*';

DivChar:
	'/';