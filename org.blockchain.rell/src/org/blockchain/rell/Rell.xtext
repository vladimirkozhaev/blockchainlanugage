grammar org.blockchain.rell.Rell with org.eclipse.xtext.common.Terminals

generate rell "http://www.blockchain.org/rell/Rell"

Model:
	entities+=Entity*
	operations+=OpDefinition*;

Entity:
	'class' name=ID ('extends' superType=[Entity])? '{'
	attributes+=Attribute*
	'}';

OpDefinition:
	"operation" name=ID "(" parameters=RelAttrubutesList? ")" "{" statements+=Statement* "}";

Statement:
	Relational ';';

Relational:
	Update | Delete | Create;

Update:
	'update' entity=ID '(' expressions=ExpressionsModel? ')';

Delete:
	'delete' entity=ID;

Create:
	'create' entity=ID;

ExpressionsModel:
	elements+=AbstractElement (',' elements+=AbstractElement*)?;

AbstractElement:
	Variable | Expression;

Variable:
	name=ID '=' expression=Expression;

Expression:
	PlusOrMinus;

PlusOrMinus returns Expression:
	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-')
	right=MulOrDiv)*;

Atomic returns Expression:
	{IntConstant} value=INT |
	{StringConstant} value=STRING |
	{BoolConstant} value=('true' | 'false') |
	{VariableRef} variable=[Variable];

MulOrDiv returns Expression:
	Atomic (({MulOrDiv.left=current} op=('*' | '/'))
	right=Atomic)*;

RelAttrubutesList:
	value+=RelAttribute (',' value+=RelAttribute)*;

RelAttribute:
	name=ID ':' reference=TypeReference;

Attribute:
	modificator=Prefix? name=ID ':' type=TypeReference ';';

TypeReference:
	primitive=PrimitiveType | entity=EntityType;

PrimitiveType:
	Text | Integer | Json | ByteArray;

EntityType:
	entity=[Entity];

Json:
	'json';

Integer:
	'integer' | 'timestamp';

Text:
	'text' | 'tuid' | 'name';

ByteArray:
	'byte_array' | 'signer' | 'guid' | 'pubkey';

Prefix:
	'key' | 'index';