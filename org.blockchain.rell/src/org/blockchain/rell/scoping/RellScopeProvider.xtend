/*
 * generated by Xtext 2.10.0
 */
package org.blockchain.rell.scoping

import java.util.List
import org.blockchain.rell.rell.AtOperator
import org.blockchain.rell.rell.AttributeListField
import org.blockchain.rell.rell.ClassDefinition
import org.blockchain.rell.rell.ClassMemberDefinition
import org.blockchain.rell.rell.ClassRef
import org.blockchain.rell.rell.ClassRefDecl
import org.blockchain.rell.rell.Expression
import org.blockchain.rell.rell.JustNameDecl
import org.blockchain.rell.rell.VariableDeclaration
import org.blockchain.rell.rell.VariableDeclarationRef
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.blockchain.rell.rell.TableNameWithAlias

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class RellScopeProvider extends AbstractDeclarativeScopeProvider {

	def IScope getVariableDeclarationRefScope(VariableDeclarationRef classType, EReference ref) {
		 
		val container=classType.eContainer;
		switch(container){
			case (container instanceof ClassMemberDefinition):{
				val classMemberDefinition=container as ClassMemberDefinition;
				val classDefinition=classMemberDefinition.classRef.value;
				var EList<AttributeListField> attrubuteListField;
				switch (classDefinition){
					case (classDefinition instanceof ClassRefDecl):{
						val classRefDecl=classDefinition as ClassRefDecl
						attrubuteListField=classRefDecl.classDef.attributeListField;
					}case (classDefinition instanceof JustNameDecl):{
						val justNameDecl=classDefinition as JustNameDecl
						attrubuteListField=justNameDecl.name.attributeListField;
					}
				}
				val List<VariableDeclaration> variableDeclarationList=newArrayList;
				if (attrubuteListField===null){
					return IScope.NULLSCOPE;
				}
				attrubuteListField.forEach[x|if (x.attributeList!==null) 
					{
						x.attributeList.forEach[attrList|
							if (attrList!==null&&attrList.value!==null){
								attrList.value.forEach[variable|{
									if (variable!==null) {
										variableDeclarationList.add(variable.name)
									}
								}]
							}
					]}
				];
							
				val scope= Scopes::scopeFor(variableDeclarationList)
				return scope
			}
		}	
		return IScope::NULLSCOPE
		
	}
	
	def IScope getClassRefScope(ClassRef classRef, EReference ref) {
		
		val container=classRef.eContainer.notExressionContainer;
		if (container instanceof ClassMemberDefinition){
			
			val notExprCont=container.eContainer.notExressionContainer
			
			 if (notExprCont instanceof AtOperator){
			 	val atOperator=notExprCont as AtOperator
				val List<TableNameWithAlias> classDefList=newArrayList
				atOperator.tableNameWithAlias.forEach[x|classDefList.add(x)]
				return Scopes::scopeFor(classDefList);
			 }
		}	
		return super.getScope(classRef,ref);
		
	}
	
	def notExressionContainer(EObject context){
		var privateContainer=context
		while (privateContainer instanceof Expression){
			privateContainer=privateContainer.eContainer
		}
		return privateContainer;
	}
	
	
	override IScope getScope(EObject context, EReference reference) {
		switch(context){
			case (context===null): return IScope.NULLSCOPE
			case (context instanceof VariableDeclarationRef):{
				return getVariableDeclarationRefScope(context as VariableDeclarationRef,reference);
			}
			case(context instanceof ClassRef):{
				return getClassRefScope(context as ClassRef,reference);
			}
		}
		return super.getScope(context,reference);	

	}


	
}


