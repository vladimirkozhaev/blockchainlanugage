/*
 * generated by Xtext 2.10.0
 */
package org.blockchain.rell.scoping

import java.util.List
import org.blockchain.rell.rell.ClassMemberDefinition
import org.blockchain.rell.rell.ClassType
import org.blockchain.rell.rell.VariableDeclaration
import org.blockchain.rell.rell.VariableDeclarationRef
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class RellScopeProvider extends AbstractDeclarativeScopeProvider {

	def IScope getVariableDeclarationRefScope(VariableDeclarationRef classType, EReference ref) {
		
		val container=classType.eContainer;
		switch(container){
			case (container instanceof ClassMemberDefinition):{
				val classMemberDefinition=container as ClassMemberDefinition;
				val attrubuteListField=classMemberDefinition.classDefinition.attributeListField;
				val List<VariableDeclaration> variableDeclarationList=newArrayList;
				attrubuteListField.forEach[x|x.attributeList.forEach[attrList|attrList.value.forEach[variable|variableDeclarationList.add(variable.name)]]];
				
				
				val scope= Scopes::scopeFor(variableDeclarationList)
				return scope
			}
		}	
		return IScope::NULLSCOPE
		
	}


	
	override IScope getScope(EObject context, EReference reference) {
		
		if (context instanceof VariableDeclarationRef){
			return getVariableDeclarationRefScope(context as VariableDeclarationRef,reference);
		}
		return super.getScope(context,reference);	

	}


	
}


