/*
 * generated by Xtext 2.14.0
 */
package org.blockchain.rell.validation

import com.google.inject.Inject
import java.util.ArrayList
import java.util.List
import org.blockchain.rell.rell.ClassDefinition
import org.blockchain.rell.rell.Expression
import org.blockchain.rell.rell.Model
import org.blockchain.rell.rell.Operation
import org.blockchain.rell.rell.RellPackage
import org.blockchain.rell.typing.RellModelUtil
import org.blockchain.rell.typing.RellType
import org.blockchain.rell.typing.RellTypeProvider
import org.blockchain.rell.typing.VariableReferenceInfo
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import org.blockchain.rell.integral.RellCompleteValidationAPI
import org.eclipse.emf.ecore.EObject
import org.blockchain.rell.rell.VariableDeclaration

/**
 * Custom validation rules.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class RellValidator extends AbstractRellValidator {

	@Inject extension RellTypeProvider
	@Inject extension RellModelUtil

	protected static val ISSUE_CODE_PREFIX = "org.blockchain.rell."

	public static val FORWARD_REFERENCE = ISSUE_CODE_PREFIX + "ForwardReference";

	public static val NOT_UNIQUE_NAME = ISSUE_CODE_PREFIX + "NotUniqueName";

	public static val NOT_INIT_VARIABLE = ISSUE_CODE_PREFIX + "NotInitVariable";

	public static val WRONG_TYPE = ISSUE_CODE_PREFIX + "WrongType";

	public static val HIERARCHY_CYCLE = ISSUE_CODE_PREFIX + "HierarchyCycle";

	public static val MORE_TNAN_ONE_VARIABLE = ISSUE_CODE_PREFIX + "Copy"

	public static val TYPE_MISMATCH = ISSUE_CODE_PREFIX + "TypeMismatch"

	public static val NOT_UNIQUE_NANE = "Name conflict"

	public static val DUPLICATE_VARIABLE_NAME = "Duplicate variable"
	
	public static val DUPLICATE_ATTRIBUTE_NAME = "Duplicate attribute"

	public static val SEMANTIC_ERROR = "It doesn't really work"

	val RellCompleteValidationAPI rellAPI = new RellCompleteValidationAPI();

	@Check
	def rellrValidate(EObject o) {
		val errs = rellAPI.validate(o)
		if (!errs.empty) {
			errs.forEach[e | 
				error(e.error,
					RellPackage.Literals.MODEL.getEIDAttribute(), SEMANTIC_ERROR)
			]
			
		}
	}

//	@Check def checkUniqueClassName(Model model) {
//		val classNames = <String>newHashSet()
//		for(classDefinition : model.entities) {
//			val name=switch(classDefinition){
//
//				case (classDefinition instanceof ClassDefinition):{
//					(classDefinition as ClassDefinition).name;
//				}
//			}
//			if(classNames.contains(name)) {
//				error("Class names should be unique. Class with name " + name + " already exists",
//					RellPackage.Literals.CLASS_DEFINITION.getEIDAttribute(), NOT_UNIQUE_NANE)
//			}
//			classNames.add(name);
//		}
//		rellrValidate(model)
//	}
//
//
//
//
//
//
//	@Check def checkUniqueAttributeName(ClassDefinition classDefinition) {
//		val attributesName = <String>newHashSet
//		for (var i = 0; i < classDefinition.attributeListField.size; i++) {
//			val values = classDefinition.attributeListField.get(i).attributeList.get(0).value
//			if (values.size > 1) {
//				for (var j = 0; j < values.size; j++) {
//					if (attributesName.contains(values.get(j).name.name)) {
//						error(
//							"Attribute with the " + values.get(j).name.name + "name already is defined",
//							RellPackage.Literals.VARIABLE_DECLARATION.EIDAttribute,
//							DUPLICATE_ATTRIBUTE_NAME
//						)
//					}
//					attributesName.add(values.get(j).name.name)
//				}
//			} else {
//				if (attributesName.contains(values.get(0).name.name)) {
//					error(
//						"Attribute with the " + values.get(0).name.name  + " name already is defined",
//						RellPackage.Literals.VARIABLE_DECLARATION.EIDAttribute,
//						DUPLICATE_ATTRIBUTE_NAME
//					)
//				}
//				attributesName.add(values.get(0).name.name)
//			}
//		}
//	}
//
//	def private checkExpectedSame(RellType left, RellType right) {
//		if (right !== null && left !== null && right != left) {
//			error("expected the same type, but was " + left + ", " + right,
//				RellPackage.Literals.EQUALITY.getEIDAttribute(), TYPE_MISMATCH)
//		}
//	}
//
//	def private checkNotBoolean(RellType type, EReference reference) {
//		if (type.isBoolean) {
//			error("cannot be boolean", reference, TYPE_MISMATCH)
//		}
//	}
//
//	def private checkExpectedBoolean(Expression exp, EReference reference) {
//		checkExpectedType(exp, RellTypeProvider.BOOL_TYPE, reference)
//	}
//
//	def private checkExpectedInt(Expression exp, EReference reference) {
//		checkExpectedType(exp, RellTypeProvider.INT_TYPE, reference)
//	}
//
//	def private checkExpectedType(Expression exp, RellType expectedType, EReference reference) {
//		val actualType = getTypeAndCheckNotNull(exp, reference)
//		if (actualType != expectedType)
//			error(
//				"expected " + expectedType + " type, but was " + actualType,
//				reference,
//				TYPE_MISMATCH
//			)
//	}
//
//	@Check
//	def void checkVariableDeclarationConflict(Operation operation) {
//		val List<VariableReferenceInfo> variableDeclarations = operation.usedVariables;
//		variableDeclarations.reverse;
//		for (var i = 0; i < variableDeclarations.length - 1; i++) {
//			val element = variableDeclarations.get(i);
//			val sublistToCheck = new ArrayList(variableDeclarations.subList(i + 1, variableDeclarations.length));
//			for (var j = 0; j < sublistToCheck.length; j++) {
//				if (sublistToCheck.get(j).variableDeclaration.name == element.variableDeclaration.name) {
//					error("The variable with the same name is already defined: " + element.variableDeclaration.name,
//					RellPackage::eINSTANCE.operation_Statements, NOT_UNIQUE_NAME)
//				}
//			}
//		}
//	}
//
//	@Check
//	def void checkVariableDeclaration(VariableDeclaration decl) {
//		rellrValidate(decl)
//	}
//
//	@Check
//	def void checkVariableDeclarationInitialized(Operation operation) {
//		val List<VariableReferenceInfo> variableDeclarations = operation.usedVariables;
//		variableDeclarations.reverse;
//		for (var i = 0; i < variableDeclarations.length - 1; i++) {
//			val element = variableDeclarations.get(i);
//			val sublistToCheck = new ArrayList(variableDeclarations.subList(i + 1, variableDeclarations.length));
//			for (var j = 0; j < sublistToCheck.length; j++) {
//				if (sublistToCheck.get(j).variableDeclaration.name == element.variableDeclaration.name) {
//					error("The variable with the same name is already defined: " + element.variableDeclaration.name,
//					RellPackage::eINSTANCE.operation_Statements, NOT_UNIQUE_NAME)
//				}
//			}
//		}
//	}
//
//	def private RellType getTypeAndCheckNotNull(Expression exp, EReference reference) {
//		val type = exp?.typeFor
//		if (type === null)
//			error("null type", reference, TYPE_MISMATCH)
//		return type;
//	}

}
